최근 인공지능 분야에서 자연어처리(NLP)는 활발하게 연구되고 있는 영역 중 하나입니다.

특히 Transformer 구조의 등장으로 인해 언어 모델의 성능이 폭발적으로 발전하였고, 그 중심에 있는 모델 중 하나가 BERT입니다.

이번 시리즈에서는 자연어처리를 처음 접하는 분들을 위해 다음과 같은 과정을 간단히 소개합니다.

오늘 다룰 내용은 `Tokenization` 입니다.

<br>
## **A. 토큰화가 왜 필요할까요?**

### 1. 컴퓨터는 글자를 직접 이해하지 못한다.

AI도 결국 컴퓨터 프로그램이라 글자 자체를 이해하지 못합니다. 
컴퓨터는 숫자만 이해하죠. 토큰화는 텍스트를 AI가 처리할 수 있는 숫자로 바꾸는 첫 단계입니다.

예를 들어, "안녕하세요"를 컴퓨터에게 그냥 주면 이해하지 못하지만, 
토큰화를 통해 [8275]와 같은 숫자로 바꿔주면 처리할 수 있습니다.

<br>

### 2. 전체 사전을 외울 수는 없다.

세상에는 너무 많은 단어가 있습니다. 
한국어만 해도 수십만 개의 단어가 있고, 새로운 단어들이 계속 생겨납니다. 
모든 단어를 각각 하나의 조각으로 처리하는 건 현실적으로 불가능해요.

대신 AI는 자주 사용되는 단어나 단어의 일부분(서브워드)을 기억합니다. 
마치 우리가 "탈모방지샴푸"라는 단어를 "탈모", "방지", "샴푸"로 나눠 이해하는 것처럼요.

<br>

### 3. 처음 보는 단어도 이해할 수 있다.

이런 방식 덕분에 AI는 훈련 과정에서 한 번도 보지 못한 단어도 어느 정도 이해할 수 있습니다.

예를 들어, "메타버스라이프스타일"이라는 새로운 단어를 마주쳐도, "메타", "버스", "라이프", "스타일"과 같은 익숙한 조각들로 분해해 의미를 추측할 수 있습니다.

<br>

### 4. 효율적인 정보 처리가 가능하다.

우리가 장문의 글을 읽을 때 한 글자씩 읽지 않고 단어나 구절 단위로 읽는 것처럼, AI도 적절한 크기의 조각으로 텍스트를 처리하면 더 효율적입니다.

토큰이 너무 작으면(예: 한 글자씩) 처리해야 할 조각이 너무 많아지고, 너무 크면(예: 문장 전체) 비슷한 패턴을 인식하기 어려워집니다.

<br>

### 5. 다양한 언어를 하나의 시스템으로 처리한다.

토큰화는 영어, 한국어, 일본어 등 서로 다른 언어를 같은 방식으로 처리할 수 있게 해줍니다. 글자 체계가 완전히 다른 언어들도 같은 AI 모델이 이해할 수 있게 되는 거죠.

<br>

### 토큰화가 AI의 능력에 미치는 영향

좋은 토큰화 시스템은

- 더 적은 메모리로 더 많은 단어를 이해할 수 있게 합니다
- 새로운 단어나 개념도 추론할 수 있게 합니다
- 다양한 언어와 방언도 처리할 수 있게 합니다
- 더 빠르고 정확하게 텍스트를 처리할 수 있게 합니다

쉽게 말해, 토큰화는 AI가 인간의 언어를 이해하고 생성하는 첫 단계이자 가장 중요한 기초 작업입니다. 

좋은 토큰화 없이는 아무리 뛰어난 AI 모델도 언어를 제대로 처리할 수 없습니다.

<br>

### 그런데 여기서 Transformer는 뭐길래 여기저기 등장할까요?

Transformer는 2017년에 소개된 인공지능 모델 구조로, 현재 ChatGPT, Claude와 같은 최신 AI 언어 모델의 핵심 기술입니다. 텍스트를 이해하고 생성하는 데 혁신적인 방법을 제시했습니다.

1. 문맥을 더 잘 이해한다. -”주변을 둘러보는 능력”
2. 병렬 처리가 가능하다. - “동시에 여러 일을 처리”
3. 장거리 의존성을 잘 잡아낸다. - “멀리 떨어진 연결 관계 파악”
4. 확장성이 뛰어나다. - “크게 키울 수 있는 잠재력”
5. 다양한 분야에 적용할 수 있다. - “만능 도구”

<br>

딱 보기만해도 엄청한 친구라는게 느껴지시죠. 이러한 장점들은 이후 포스터에서 다뤄보겠습니다.

자 이제, LLM의 완전 기반이 되는 토큰화에 대해서 구체적으로 알아보겠습니다.

<br>

## **B. 토큰화(Tokenization)는 어떻게 동작할까?**

### 1. 자연어처리의 전통적인 흐름

자연어를 처리하는 과정은 다음과 같습니다.

> 🔥
> Sentence -> Tokens -> Embedding -> Transformer -> Down-Stream Layer -> Output

- **sentence** : 사람이 읽을 수 있는 문장(텍스트)
- **Tokens** : 문장을 일정한 기준(띄어쓰기, 서브워드 등)에 따라 나눈 단위들
- **Embedding** : 토큰(Token)을 벡터(Vector)로 변환해주는 단계
- **Transformer** : Embedding 을 입력받아 Attention 메커니즘을 통해 문맥 정보를 학습
- **Down-Stream Layer** : 분류, 회귀, 질문 답변 등 원하는 최종 과제를 해결하기 위한 추가 레이어
- **Output**: 최종 예측 결과(레이블, 점수, 답변 등)

<br>

과거에는 Word2Vec 처럼 임베딩을 별도로 학습한 뒤, 학습된 임베딩을 다른 모델에 입력을 넣는 방식이 많았습니다. 

그러나 최근의 대형 언어 모델(LLM)은 내부에 임베딩 레이어가 포함되어 있어, 
텍스트(토큰)를 숫자 벡터로 변환하는 과정을 모델 구조의 일부로 직접 수행합니다.

<br>

### 2. 토크나이저와 임베딩

**자연어를 기계가 이해하기 위해서는 우선 문장을 토큰(token) 단위로 나누어야 합니다.**

이 과정을 **토크나이징**(tokenizing)이라고 하며, 주로 다음과 같은 방식이 있습니다.

1. **단순 띄어쓰기 기반**(whitespace tokenization)

단순하고 빠르지만 형태소 분석이 없어서 "나는"과 "나"를 구분하지 못하는 단점이 있다. 또한 문장부호도 함께 포함되는 문제가 있다.

```python
입력 문장: "나는 오늘 영화를 봤다."
토큰화 결과: ["나는", "오늘", "영화를", "봤다."]
```

<br>

2. **단어 기반**(tokenization by words)

어휘단위로 분리가 가능하지만, 새로운 단어(신조어, 복합명사 등)에 취약하다.

```python
//한글 형태소 분석기 활용
입력 문장: "나는 오늘 영화를 봤다."
토큰화 결과: ["나", "는", "오늘", "영화", "를", "보다", "ㅆ다"]
```

<br>

3. **서브워드 기반**(subword)

단어보다 작은 단위로 분리하여 희귀 단어 처리(OOV)를 효과적으로 수행하는 방법입니다.

BPE(Byte Pair Encoding)나 WordPiece 같은 기법이 대표적이며. BERT, GPT 등의 NLP 모델에서 사용됩니다.

신조어, 희귀 단어를 효과적으로 처리 가능하지만, 사전 구축을 위해 학습 과정이 필요하다.

- BPE 토크나이저

```python
입력 문장: "나는 오늘 영화를 봤다."
초기 토큰화: ["나", "는", "오늘", "영화", "를", "봤", "다."]
자주 나오는 문자 조합 병합 후: ["나는", "오늘", "영화", "를", "봤다."]
```

여기서 "자주 나오는 문자 조합 병합" 이라는 말은 가장 자주 등장하는 문자 또는 단어 쌍을 병합하면서 토큰을 구성하는 겁니다.

즉, 처음에는 모든 단어를 가장 작은 단위(자모 또는 개별 문자)로 쪼갠 후, 빈도를 기반으로 점진적으로 병합합니다.

- WordPiecee - BERT

```python
입력 문장: "비행기가 날아가고 있다."
토큰화 결과: ["비행", "##기가", "날아", "##가고", "있", "##다", "."]
```

<br>


4. **문자 기반**(character)

각 문자를 하나의 토큰으로 간주하는 방식입니다. 예를 들어, 단어를 더 작은 단위로 쪼개어 처리할 수 있습니다.

사전에 없는 단어도 처리할 수 있는 장점은 있지만, 너무 길어질 경우 모델이 문맥을 학습하기 어려워집니다.

```python
입력 문장: "나는 오늘 영화를 봤다."
토큰화 결과: ["나", "는", " ", "오", "늘", " ", "영", "화", "를", " ", "봤", "다", "."]
```

자, 대충 어떤 방식의 토크나이징이 있는지 살펴보았고, 좀 더 디테일하게 BPE를 가지고 다뤄보겠습니다.

<br>

**"글자"** 를 BPE 방식으로 처리하는 과정을 살펴보자면,

**초기 상태(모든 문자 개별 분리)**

> ["ㄱ", "ㅡ", "ㄹ", "ㅈ", "ㅏ"]
> 

**빈도를 분석하여 가장 자주 등장하는 쌍을 병합**

> ["그", "ㄹ", "ㅈ", "ㅏ"] -> 가정적으로 "ㄱ" + "-" 가 자주 등장한다고 하면, 이를 하나의 토큰으로 병합합니다.
> 

**그 다음으로 "ㄹ" + "ㅈ"이 자주 등장하면 병합**

> ["그", "ㄹ자"]
> 

**그 다음으로 "그" + "ㄹ자" 가 자주 등장하면 병합**

> ["글자"]
> 

<br>

이제 "글자"는 하나의 토큰이 되어 vocabulary(어휘 사전)에 추가됩니다.

실제 NLP 모델에서는 단 하나의 단어가 아니라 수백만 개의 단어가 포함된 Corpus(코퍼스, 말뭉치)에서 이러한 병합을 수행합니다.

이러한 방식으로 목표 어휘 크기(Vocab Num 예: 30만개 단어)가 될 때까지 병합을 반복합니다.

<br>

### 3. 왜 이런 방식을 사용할까요?

**1. 신조어, 희귀 단어 처리**

- 예를 들어 "코로나19" 라는 단어가 처음 등장했을 때, 기존 사전에 없더라도 "코", "로", "나", "19" 같은 조합으로 처리가 가능합니다.
- 새로운 단어도 서브워드 단위로 처리하여 Out-Of-Vocabulary 문제를 줄일 수 있습니다.

**2. 어휘 크기 감소**

- 한국어는 조사(을, 를, 은, 는 등)와 동사 변화(먹다, 먹고, 먹었다 등)가 많습니다.
- "먹다", "먹고", "먹었다" 를 각각 저장하는 대신, "먹" + ["##다", "##고", "##었다"] 로 저장하면 사전을 줄일 수 있습니다.

**3. 모델의 범용성 향상**

- 문장을 단어 단위로 쪼개는 방식보다, 서브워드 방식을 사용하면 훨씬 다양한 언어 패턴을 효과적으로 학습할 수 있습니다.

<br>
<br>

## **C. 뉴스 기사를 이용한 간단한 토크나이저 만들기**

뉴스 기사를 기반으로 직접 토크나이저를 만들어 보고, 동작하는 코드를 실행하면서 **토큰화 과정**을 보여보겠습니다.

마지막에는 토크나이저 라이브러리를 사용하여 간단하게 토큰화 하는 방법도 알려드리겠습니다.

### 1. 뉴스 기사 Corpus 준비하기(뉴스 기사 2개)

```python
# 뉴스 기사 Corpus (2개의 기사)
corpus = [
    """(대전=연합뉴스) 양영석 기자 = 교내에서 8살 김하늘 양을 흉기로 살해하고 자해를 시도했던 대전 모 초등학교 여교사가
    나흘 전에도 폭력적인 성향을 보여 주변을 긴장시켰던 것으로 전해졌다.
    11일 대전시교육청과 경찰 등에 따르면 해당 교사는 지난 6일 동료 교사의 팔을 꺾는 등 폭력적인 행동을 보였다.""",

    """최상목 대통령 권한대행이 "무엇보다 시급한 것은 연금개혁"이라며 "하루속히 국회가 합의안을 도출해달라"고 촉구했습니다.
    최상목 권한대행은 오늘(11일) 정부서울청사에서 국무회의를 주재한 자리에서 "국민연금이 지금처럼 운영된다면 2041년에 적자로 전환되고
    2056년에는 기금이 완전히 소진될 것"이라며 이같이 밝혔습니다."""
]
```

이제 이를 실제 토큰으로 분리하는 과정을 진행해보겠습니다.

<br>

### 2. 뉴스 기사 토크나이징(Tokenization)

이제 어떠한 최소단위로 Sentence를 모두 쪼개야 합니다.

여기서는 가장 간단한 작업을 수행할 것이기 때문에, 한글을 제외한 특수문자를 모두 제외하고 음절 단위로 모든 문장을 분리하였다.

실제로는 이 과정이 상당히 중요한 과정인데. 한글의 경우 이 과정이 특히 어렵습니다.

이유는 영어와 다르게 '조사'의 존재로 의미가 상당히 크게 달라지기도 하며 띄어쓰기가 잘 지켜지지 않는 언어이기 때문이다.

BPE 방식의 토크나이징을 단계적으로 수행해보겠습니다.

```python
import re

def tokenize_syllables(corpus):
    """문장을 음절 단위로 분리하여 토큰화하는 함수"""
    tokenized = []

    for sentence in corpus:
# 한글과 공백만 남기고 제거
        sentence = re.sub(r"[^가-힣\s]", "", sentence)
# 연속된 공백을 하나의 공백으로 변환 후, 양쪽 공백 제거
        sentence = re.sub(r"\s+", " ", sentence).strip()
# 음절 단위로 분리
        syllables = list(sentence)
        tokenized.append(syllables)

    return tokenized

# 토큰화 실행
tokenized_corpus = tokenize_syllables(corpus)

# 결과 출력for idx, tokens in enumerate(tokenized_corpus):
    print(f"문장 {idx + 1}: {tokens}")
```

```
문장 1: ['대', '전', '연', '합', '뉴', '스', ' ', '양', '영', '석', ' ', '기', '자', ' ', '교', '내', '에', '서', ' ', '팔', '을', ' ', '꺾', '는', ' ', '등', ' ', '폭', '력', '적', '인', ' ', '행', '동', '을', ' ', '보', '였', '다']
문장 2: ['최', '상', '목', ' ', '대', '통', '령', ' ', '권', '한', '대', '행', '이', ' ', '시', '급', '한', ' ', '것', '은', ' ', '연', '금', '개', '혁', '이', '라', '며', ' ', '국', '회', '가', ' ', '합', '의', '안', '을', ' ', '도', '출', '해', '달', '라', '고']
```

<br>

### 3. 음절 쌍의 빈도 계산하기

동시출현 빈도 계산해보겠습니다.

```python
from collections import defaultdict

def get_pair_frequencies(tokenized_corpus):
    """음절 쌍의 동시출현 빈도를 계산하는 함수"""
    pair_frequencies = defaultdict(int)

    for sentence in tokenized_corpus:
        for i in range(len(sentence) - 1):
            pair = (sentence[i], sentence[i + 1])# 연속된 두 개의 음절 쌍
            pair_frequencies[pair] += 1# 빈도 증가return pair_frequencies

# 동시출현 빈도 계산 실행
pair_frequencies = get_pair_frequencies(tokenized_corpus)

# 결과 출력 (빈도수가 높은 순으로 정렬)
sorted_frequencies = sorted(pair_frequencies.items(), key=lambda x: x[1], reverse=True)
for pair, freq in sorted_frequencies[:10]:# 상위 10개만 출력
    print(f"쌍: {pair}, 빈도: {freq}")
```

```
쌍: ('대', '전'), 빈도: 6
쌍: ('전', '연'), 빈도: 1
쌍: ('연', '합'), 빈도: 1
쌍: ('합', '뉴'), 빈도: 1
쌍: ('뉴', '스'), 빈도: 1
쌍: (' ', '양'), 빈도: 2
쌍: ('양', '영'), 빈도: 1
쌍: ('영', '석'), 빈도: 1
쌍: ('하', '지'), 빈도: 1
쌍: ('않', '도'), 빈도: 1
```

'대'와 '전'은 **6번 등장**하며, 하나의 단어("대전")로 병합하는 것이 유리합니다.

대부분의 다른 쌍은 1~2회 등장 → 아직 병합할 필요 없습니다.

<br>

### 4. 음절 쌍의 빈도 계산하기

우리가 가진 데이터에서 가장 자주 등장하는 음절 쌍을 병합하여 새로운 토큰을 생성하는 과정입니다.

```python
def merge_most_frequent_pair(tokenized_corpus, pair):
    """가장 빈번한 음절 쌍을 하나의 토큰으로 병합하는 함수"""
    new_corpus = []
    new_token = "".join(pair)# 쌍을 하나의 단어로 병합for sentence in tokenized_corpus:
        new_sentence = []
        i = 0
        while i < len(sentence):
# 가장 빈번한 쌍을 발견하면 병합하여 추가if i < len(sentence) - 1 and (sentence[i], sentence[i + 1]) == pair:
                new_sentence.append(new_token)
                i += 2# 병합된 부분을 건너뜀else:
                new_sentence.append(sentence[i])
                i += 1
        new_corpus.append(new_sentence)

    return new_corpus
```

("대", "전") 과 같이 가장 빈번한 음절 쌍을 찾아 "대전"으로 병합합니다.

Corpus를 업데이트하면서 점진적으로 새로운 서브워드 토큰을 생성합니다.

<br>

### 5. WordPiece 토크나이저 학습하기

이제 목표하는 어휘(Vocab) 크기까지 반복하여 새로운 토큰을 만들어 내는 과정을 구현합니다.

```python
def train_wordpiece(corpus, vocab_size):
    """WordPiece 토크나이저 학습"""
    tokenized_corpus = tokenize_syllables(corpus)# 음절 단위 토큰화
    vocab = []

    while len(vocab) < vocab_size:
        pair_frequencies = get_pair_frequencies(tokenized_corpus)

        if not pair_frequencies:# 병합할 쌍이 더 이상 없으면 종료break

# 가장 빈번한 음절 쌍 찾기
        most_frequent_pair = max(pair_frequencies, key=pair_frequencies.get)

# 해당 쌍을 병합하여 새로운 토큰 생성
        tokenized_corpus = merge_most_frequent_pair(tokenized_corpus, most_frequent_pair)

# 새로운 병합된 토큰을 Vocabulary에 추가
        merged_token = "".join(most_frequent_pair)
        vocab.append(merged_token)

# 중복 제거 후 정렬
        vocab = list(set(vocab))

    return sorted(vocab), tokenized_corpus
```

<br>

### 6. WordPiece 학습 결과

위 코드가 실행되면 자연스럽게 새로운 단어 단위(Token)가 생성됩니다.

```python
final_vocab, final_tokenized_corpus = train_wordpiece(corpus, vocab_size=100)

print("최종 Vocab:", final_vocab)
print("Vocab Len:", len(final_vocab))
```

출력 결과

```python
최종 Vocab: [' 경찰 ', ' 교', ' 교사', ' 대', ' 대전', ' 동료 교사', ' 사', ' 사건', ' 양', ' 있', ' 정', '가 ', '것이', '게 ', '경찰', '경찰 ', '고 ',
'관련', '국민', '국민연금', '는 ', '다 ', '다고 ', '다고 말', '다는 ', '대전', '던 ', '도 ', '동료', '동료 교사', '들이 ', '등 ', '라며 ', '로 ',
'를 ', '며 ', '면 ', '서 ', '습니', '시 ', '시교', '시교육청', '았다 ', '야 ', '야 할', '에 ', '에게 ', '에서 ', '여교', '여교사', '연금', '와 ',
'육청', '으로 ', '은 ', '을 ', '을 강', '을 강하', '을 강하게 ', '을 보', '의 ', '의 팔', '의 팔을 ', '의 팔을 꺾', '의 팔을 꺾는 ',
'의 팔을 꺾는 등 ', '이 ', '일 대전', '적인', '적인 ', '전해', '졌다 ', '주변', '지 ', '지 않', '지난', '지만', '초등', '최 대', '최 대행은 ',
'폭력', '폭력적인 ', '하고 ', '하늘', '학교', '학교 ', '학교 측', '한 ', '한 것', '한 것으로 ', '한 것으로 알', '해 ', '해당', '해당 교사',
'해당 교사는 ', '했습니', '했습니다 ', '행은 ', '휴직', '히 ‘]

Vocab Len: 100
```

✅ "대전" → **빈번하게 등장하여 병합됨**

✅ "동료 교사" → **단어 조합이 자주 등장하여 병합됨**

✅ "국민연금" → **뉴스에서 반복적으로 사용되어 하나의 단어로 병합됨**

✅ "의 팔을 꺾는 등" → **Corpus가 적어 일반적인 NLP에서는 나오지 않는 형태도 포함됨**

<br>
<br>

## **D. 라이브러리를 통해 쉽게 토큰화 진행**

실제로 Hugging face의 `tokenizers` 라이브러리와 `datasets` 를 활용하여 토큰화를 구현해 보겠습니다.

<br>

**필요한 라이브러리 설치**

```python
pip install transformers tokenizers datasets
```

<br>

**데이터셋 로드하기**

우선 학습에 사용할 데이터셋을 불러옵니다. 여기서는 Hugging Face의 `datasets` 라이브러리를 사용하여 한국어/영어 데이터셋을 로드합니다.

```python
from datasets import load_dataset

# 데이터셋 로드
dataset = load_dataset("bongsoo/social_science_en_ko", split='train')

# 특정 컬럼의 데이터 추출
dataset_corpus = dataset['제2항을 함께 두는 것이 적절한지에 대하여 논의 과정에서 의문이 제기되기도 하였다.']

# 데이터 샘플링 (메모리 관리를 위해)
dataset_sample = dataset_corpus[:1000000]
```

<br>

**토크나이저 학습시키기**

이제 BPE(Byte Pair Encoding) 알고리즘을 사용하는 토크나이저를 정의하고 학습시켜 보겠습니다.

```python
from tokenizers import Tokenizer
from tokenizers.models import BPE
from tokenizers.trainers import BpeTrainer
from tokenizers.pre_tokenizers import Whitespace

# BPE 토크나이저 초기화
tokenizer = Tokenizer(BPE(unk_token="[UNK]"))

# 공백 기준 pre-tokenizing 설정
tokenizer.pre_tokenizer = Whitespace()

# 토크나이저 트레이너 설정
trainer = BpeTrainer(
    vocab_size=32000,  # 어휘 크기
    special_tokens=["[PAD]", "[UNK]", "[CLS]", "[SEP]", "[MASK]"],  # 특수 토큰
)

# 데이터로부터 토크나이저 학습
tokenizer.train_from_iterator(dataset_sample, trainer)
```

<br>

**학습된 토크나이저 사용하기**

이제 학습된 토크나이저를 사용하여 텍스트를 토큰화해 보겠습니다.

```python
# 토크나이저 저장
tokenizer.save("my_tokenizer.json")

# 토크나이저 로드
loaded_tokenizer = Tokenizer.from_file("my_tokenizer.json")

# 한국어 토큰화 예시
text = "이런 것도 잘 분해하나?"
tokens = loaded_tokenizer.encode(text)
print("입력 문장:", text)
print("토큰화 결과:", tokens.tokens)
print("토큰 ID:", tokens.ids)

# 결과 예시:
# 입력 문장: 이런 것도 잘 분해하나?
# 토큰화 결과: ['이런', '것도', '잘', '분해', '하나', '?']
# 토큰 ID: [3970, 4321, 2574, 7554, 3521, 35]
```

위 예시에서 “이런 것도 잘 분해하나?” 라는 문장이 어떻게 토큰화되는지 살펴보겠습니다.

```python
입력 문장: 이런 것도 잘 분해하나?
토큰화 결과: ['이런', '것도', '잘', '분해', '하나', '?']
토큰 ID: [3970, 4321, 2574, 7554, 3521, 35]
```

<br>

이제 토큰화 결과를 자세히 살펴보겠습니다. 위 예시에서 우리는 몇 가지 흥미로운 점들을 발견할 수 있습니다.

**1. 의미 단위의 분리**

BPE 토크나이저는 한국어 문장을 매우 효과적으로 의미 단위로 분리했습니다. "이런", "것도", "잘", "분해", "하나"와 같이 각각의 의미를 가진 단위로 깔끔하게 토큰화되었죠.

<br>

**2. 조사 처리의 특징**

'것도'처럼 명사와 조사가 결합된 형태를 하나의 토큰으로 인식한 점이 인상적입니다. 이는 토크나이저가 한국어의 특성을 잘 학습했다는 증거입니다.

<br>

**3. 동사 분해 방식**

흥미롭게도 '분해하나'가 '분해'와 '하나'로 분리되었습니다. 이는 토크나이저가 명사 '분해'와 동사 '하다'의 활용형을 구분할 수 있음을 보여줍니다.

<br>

**4. 특수문자 처리 방법**

물음표('?')를 별도의 토큰으로 분리한 것도 주목할 만합니다. 이처럼 특수문자도 개별 토큰으로 처리되어 문장의 의미를 더욱 정확하게 파악할 수 있습니다.

<br>

**5. 토큰 ID 시스템**

각 토큰에는 고유한 ID가 부여됩니다. 이 ID는 모델이 텍스트를 처리할 때 사용되며, 작은 숫자일수록 학습 데이터에서 자주 등장했거나 중요한 특수 토큰일 가능성이 높습니다. 
이러한 과정을 우리는 `인코딩(encoding)` 이라고 합니다. 그리고 이렇게 인코딩된 숫자 ID를 다시 텍스트로 변환하는 작업을 `디코딩(decoding)` 이라고합니다.

<br>

위에서 생성된 토큰 ID (예: [3970, 4321, 2574, 7554, 3521, 35])가 바로 **Transformer** 모델의 실제 입력값이 됩니다. 


> 🔥
> Sentence -> Tokens -> Embedding -> Transformer -> Down-Stream Layer -> Output

다음 과정인 `Embdding` 에 대해선 다음 시간에 다춰보겠습니다.

감사합니다.